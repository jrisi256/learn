* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

p {
    margin-bottom: 20px;
}

.menu {
    height: 100px;
    background-color: #B2D6FF;
}

/* The float property gives us control over the horizontal position of an element. By floating the sidebar to the left, we're telling the browser to align it to the left side of the page. It ALSO tells surrounding elements they can flow around the sidebar instead of being underneath it.*/

/* Floated boxes always align to the left or the right in the context of their parent element. */

.sidebar {
    height: 300px;
    background-color: #F09A9D;
    width: 200px;
    float: left;
}

.content {
    height: 500px;
    background: #F5CF8E;
    width: 650px;
    float: left;
    padding: 20px;
}

.article-image {
    float:left;
    width: 300px;
    height: 200px;
    margin-right: 20px;
    margin-left: 20px;
}

/* You'll notice our footer element gets farmed up when we float sidebar and content. This is because floated boxes are removed from the normal flow of the page. The height of our floated elements don't contribute to the vertical position of the footer so the it simply sticks itself to the last element that wasn't floated. */

/* Can solve this by clearing a float. We tell a block to ignore any floats that appear before it. Instead of flowing around the floated box, a cleared element always appears after any floats. It's like forcing a box back into the default vertical flow of the page. */

/* However, clearing floats only fixes our issue when there's an element inside the container element that we can add a clear property to. This is also known as clearing with a "child element". */

.footer {
    clear: left; /* can also only clear left or right floats */
    background-color: #D6E9FE;
    overflow: hidden;
    /* height: 200px; */
}

/* Our border clearly demonstrates how sidebar and content no longer contribute to the dimensions of page. */

/* One way to fix our clearing issue is by using the overflow property. This is known as clearing with a "parent element". We're basically telling the container element to recognize the height of any floated elements it contains. */

/* We want full-bleed. We want the background to take up the entire browser window without changing the alignment of our sidebar or content blocks. The problem is that our "page" is busy centering everything. We cannot use it for full-bleed because centering requires an explicit width. So we add a new HTML element "container". */

.page {
    width: 900px;
    margin: 0 auto;
    border: 1px solid red;
    
}

.container {
    background-color: #EAEDF0;
    overflow: hidden;
}

/* percentages in CSS are relative to the width of the parent element. Causes them to automatically resize to browser window. Responsive design! */
.column {
    float: left;
    width: 31%;
    margin: 20px 1.15%;
    height: 160px;
    background-color: #B2D6FF;
}

.avatar {
    float: left;
    width: 60px;
    height: 60px;
    margin: 25px;
    border-radius: 40px;
    background-color: #D6E9FE;
  }
  
  .username {
    margin-top: 2%;
  }
  
/* Another trick for using overflow: hidden. Sticking it in an HTML element makes sure it horizontally clears another floating image. Basically ignore that it is a float and treat it as if it were not a floating HTML element (horizontally! normally it would stack vertically). */

  .comment {
    margin: 2%;
    overflow: hidden;
  }